{"version":3,"file":"simplify.js","sources":["../../../../../node_modules/ol/geom/flat/simplify.js"],"sourcesContent":["/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}