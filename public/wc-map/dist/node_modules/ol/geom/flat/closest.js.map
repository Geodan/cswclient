{"version":3,"file":"closest.js","sources":["../../../../../node_modules/ol/geom/flat/closest.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n"],"names":["squaredDx","squaredDistance"],"mappings":"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","x_google_ignoreList":[0]}