{"version":3,"file":"textpath.js","sources":["../../../../../node_modules/ol/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation\n) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate =\n    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii; ) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (\n        offset + stride < end &&\n        segmentM + segmentLength < startM + charLength + len / 2\n      ) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse\n      ? text.substring(ii - iStart, ii - i)\n      : text.substring(iStart, i);\n    interpolate =\n      segmentLength === 0\n        ? 0\n        : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,cAAc;AAC9B,EAAE,eAAe;AACjB,EAAE,MAAM;AACR,EAAE,GAAG;AACL,EAAE,MAAM;AACR,EAAE,IAAI;AACN,EAAE,MAAM;AACR,EAAE,QAAQ;AACV,EAAE,KAAK;AACP,EAAE,wBAAwB;AAC1B,EAAE,IAAI;AACN,EAAE,KAAK;AACP,EAAE,QAAQ;AACV,EAAE;AACF,EAAE,IAAI,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;AACnC,EAAE,IAAI,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACvC,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AACb,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AACb,EAAE,IAAI,aAAa,GAAG,CAAC,CAAC;AACxB,EAAE,IAAI,QAAQ,GAAG,CAAC,CAAC;AACnB;AACA,EAAE,SAAS,OAAO,GAAG;AACrB,IAAI,EAAE,GAAG,EAAE,CAAC;AACZ,IAAI,EAAE,GAAG,EAAE,CAAC;AACZ,IAAI,MAAM,IAAI,MAAM,CAAC;AACrB,IAAI,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;AACjC,IAAI,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACrC,IAAI,QAAQ,IAAI,aAAa,CAAC;AAC9B,IAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;AAC7E,GAAG;AACH,EAAE,GAAG;AACL,IAAI,OAAO,EAAE,CAAC;AACd,GAAG,QAAQ,MAAM,GAAG,GAAG,GAAG,MAAM,IAAI,QAAQ,GAAG,aAAa,GAAG,MAAM,EAAE;AACvE;AACA,EAAE,IAAI,WAAW;AACjB,IAAI,aAAa,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,QAAQ,IAAI,aAAa,CAAC;AAClE,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AAC3C,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AAC3C;AACA,EAAE,MAAM,WAAW,GAAG,MAAM,GAAG,MAAM,CAAC;AACtC,EAAE,MAAM,WAAW,GAAG,QAAQ,CAAC;AAC/B,EAAE,MAAM,IAAI,GAAG,MAAM,GAAG,KAAK,GAAG,wBAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAC5E,EAAE,OAAO,MAAM,GAAG,GAAG,GAAG,MAAM,IAAI,QAAQ,GAAG,aAAa,GAAG,IAAI,EAAE;AACnE,IAAI,OAAO,EAAE,CAAC;AACd,GAAG;AACH,EAAE,WAAW,GAAG,aAAa,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,QAAQ,IAAI,aAAa,CAAC;AAC5E,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AACzC,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AACzC;AACA;AACA,EAAE,IAAI,OAAO,CAAC;AACd,EAAE,IAAI,QAAQ,EAAE;AAChB,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAC9C,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAChD,IAAI,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAChC,GAAG,MAAM;AACT,IAAI,OAAO,GAAG,MAAM,GAAG,IAAI,CAAC;AAC5B,GAAG;AACH;AACA,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC;AACrB,EAAE,MAAM,MAAM,GAAG,EAAE,CAAC;AACpB,EAAE,MAAM,aAAa,GAAG,WAAW,GAAG,MAAM,KAAK,MAAM,CAAC;AACxD;AACA,EAAE,MAAM,GAAG,WAAW,CAAC;AACvB,EAAE,aAAa,GAAG,CAAC,CAAC;AACpB,EAAE,QAAQ,GAAG,WAAW,CAAC;AACzB,EAAE,EAAE,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;AAC/B,EAAE,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACnC;AACA,EAAE,IAAI,aAAa,CAAC;AACpB;AACA,EAAE,IAAI,aAAa,EAAE;AACrB,IAAI,OAAO,EAAE,CAAC;AACd;AACA,IAAI,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;AACjD,IAAI,IAAI,OAAO,EAAE;AACjB,MAAM,aAAa,IAAI,aAAa,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC;AACpD,KAAK;AACL,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC;AAClC,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,CAAC;AAClC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;AACjE,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG;AACH;AACA;AACA,EAAE,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAClC;AACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,IAAI;AAC9C,IAAI,OAAO,EAAE,CAAC;AACd,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;AAC7C,IAAI,IAAI,OAAO,EAAE;AACjB,MAAM,KAAK,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC;AACpC,KAAK;AACL,IAAI,IAAI,aAAa,KAAK,SAAS,EAAE;AACrC,MAAM,IAAI,KAAK,GAAG,KAAK,GAAG,aAAa,CAAC;AACxC,MAAM,KAAK,IAAI,KAAK,GAAG,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAC/D,MAAM,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,QAAQ,EAAE;AACtC,QAAQ,OAAO,IAAI,CAAC;AACpB,OAAO;AACP,KAAK;AACL,IAAI,aAAa,GAAG,KAAK,CAAC;AAC1B;AACA,IAAI,MAAM,MAAM,GAAG,CAAC,CAAC;AACrB,IAAI,IAAI,UAAU,GAAG,CAAC,CAAC;AACvB,IAAI,OAAO,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;AACxB,MAAM,MAAM,KAAK,GAAG,OAAO,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7C,MAAM,MAAM,GAAG,GAAG,KAAK,GAAG,wBAAwB,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;AAC7E,MAAM;AACN,QAAQ,MAAM,GAAG,MAAM,GAAG,GAAG;AAC7B,QAAQ,QAAQ,GAAG,aAAa,GAAG,MAAM,GAAG,UAAU,GAAG,GAAG,GAAG,CAAC;AAChE,QAAQ;AACR,QAAQ,MAAM;AACd,OAAO;AACP,MAAM,UAAU,IAAI,GAAG,CAAC;AACxB,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,MAAM,EAAE;AACtB,MAAM,SAAS;AACf,KAAK;AACL,IAAI,MAAM,KAAK,GAAG,OAAO;AACzB,QAAQ,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,MAAM,EAAE,EAAE,GAAG,CAAC,CAAC;AAC3C,QAAQ,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAClC,IAAI,WAAW;AACf,MAAM,aAAa,KAAK,CAAC;AACzB,UAAU,CAAC;AACX,UAAU,CAAC,MAAM,GAAG,UAAU,GAAG,CAAC,GAAG,QAAQ,IAAI,aAAa,CAAC;AAC/D,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AACxC,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;AACxC,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,UAAU,GAAG,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AACtD,IAAI,MAAM,IAAI,UAAU,CAAC;AACzB,GAAG;AACH,EAAE,OAAO,MAAM,CAAC;AAChB;;;;","x_google_ignoreList":[0]}