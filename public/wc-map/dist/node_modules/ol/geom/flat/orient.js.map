{"version":3,"file":"orient.js","sources":["../../../../../node_modules/ol/geom/flat/orient.js"],"sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean|undefined} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  let startOrientation;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\n    if (startOrientation === undefined) {\n      startOrientation = orientation;\n    }\n    if (orientation === startOrientation) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n"],"names":["reverseCoordinates"],"mappings":"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","x_google_ignoreList":[0]}