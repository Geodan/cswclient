{"version":3,"file":"expression.js","sources":["../../../../node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {isStringColor} from '../color.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    style: {},\n  };\n}\n\n/**\n * @param {string} typeHint Type hint\n * @return {number} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return StringType;\n    case 'color':\n      return ColorType;\n    case 'number':\n      return NumberType;\n    case 'boolean':\n      return BooleanType;\n    case 'number[]':\n      return NumberArrayType;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context, typeHint) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      let type = StringType;\n      if (isStringColor(encoded)) {\n        type |= ColorType;\n      }\n      // apply the given type hint only if it won't result in an empty type\n      if (!isType(type & typeHint, NoneType)) {\n        type &= typeHint;\n      }\n      return new LiteralExpression(type, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context, typeHint);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  if (typeHint) {\n    type &= typeHint;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n};\n\n/**\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\n * Third argument is a type hint\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createParser(\n    ([_, typeHint]) => {\n      if (typeHint !== undefined) {\n        return getTypeFromHint(\n          /** @type {string} */ (\n            /** @type {LiteralExpression} */ (typeHint).value\n          )\n        );\n      }\n      return AnyType;\n    },\n    withArgsCount(1, 2),\n    withGetArgs\n  ),\n  [Ops.Var]: createParser(\n    ([firstArg]) => firstArg.type,\n    withArgsCount(1, 1),\n    withVarArgs\n  ),\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\n  [Ops.Concat]: createParser(\n    StringType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.GeometryType]: createParser(StringType, withNoArgs),\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\n  [Ops.Time]: createParser(NumberType, withNoArgs),\n  [Ops.Any]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.All]: createParser(\n    BooleanType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Not]: createParser(\n    BooleanType,\n    withArgsCount(1, 1),\n    parseArgsOfType(BooleanType)\n  ),\n  [Ops.Equal]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.NotEqual]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThan]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.LessThanOrEqualTo]: createParser(\n    BooleanType,\n    withArgsCount(2, 2),\n    parseArgsOfType(AnyType),\n    narrowArgsType\n  ),\n  [Ops.Multiply]: createParser(\n    (parsedArgs) => {\n      let outputType = NumberType | ColorType;\n      for (let i = 0; i < parsedArgs.length; i++) {\n        outputType &= parsedArgs[i].type;\n      }\n      return outputType;\n    },\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType | ColorType),\n    narrowArgsType\n  ),\n  [Ops.Divide]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Add]: createParser(\n    NumberType,\n    withArgsCount(2, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Subtract]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Clamp]: createParser(\n    NumberType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Mod]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Pow]: createParser(\n    NumberType,\n    withArgsCount(2, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Abs]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Floor]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Ceil]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Round]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sin]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Cos]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Atan]: createParser(\n    NumberType,\n    withArgsCount(1, 2),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Sqrt]: createParser(\n    NumberType,\n    withArgsCount(1, 1),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Match]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 2; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(4, Infinity),\n    withEvenArgs,\n    parseMatchArgs\n  ),\n  [Ops.Between]: createParser(\n    BooleanType,\n    withArgsCount(3, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Interpolate]: createParser(\n    (parsedArgs) => {\n      let type = ColorType | NumberType;\n      for (let i = 3; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      return type;\n    },\n    withArgsCount(6, Infinity),\n    withEvenArgs,\n    parseInterpolateArgs\n  ),\n  [Ops.Case]: createParser(\n    (parsedArgs) => {\n      let type = AnyType;\n      for (let i = 1; i < parsedArgs.length; i += 2) {\n        type &= parsedArgs[i].type;\n      }\n      type &= parsedArgs[parsedArgs.length - 1].type;\n      return type;\n    },\n    withArgsCount(3, Infinity),\n    withOddArgs,\n    parseCaseArgs\n  ),\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\n  [Ops.Number]: createParser(\n    NumberType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.String]: createParser(\n    StringType,\n    withArgsCount(1, Infinity),\n    parseArgsOfType(AnyType)\n  ),\n  [Ops.Array]: createParser(\n    (parsedArgs) => {\n      return parsedArgs.length === 3 || parsedArgs.length === 4\n        ? NumberArrayType | ColorType\n        : NumberArrayType;\n    },\n    withArgsCount(1, Infinity),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Color]: createParser(\n    ColorType,\n    withArgsCount(3, 4),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Band]: createParser(\n    NumberType,\n    withArgsCount(1, 3),\n    parseArgsOfType(NumberType)\n  ),\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\n * An argument validator applies various checks to an encoded expression arguments\n * Returns the parsed arguments if any.\n * Third argument is the array of parsed arguments from previous validators\n * Fourth argument is an optional type hint\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  if (encoded.length === 3) {\n    const hint = parse(encoded[2], context);\n    return [arg, hint];\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\n  const varName = encoded[1];\n  if (typeof varName !== 'string') {\n    throw new Error('Expected a string argument for var operation');\n  }\n  context.variables.add(varName);\n  if (\n    !('variables' in context.style) ||\n    context.style.variables[varName] === undefined\n  ) {\n    return [new LiteralExpression(AnyType, varName)];\n  }\n  const initialValue = context.style.variables[varName];\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\n  arg.value = varName;\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\n    throw new Error(\n      `The variable ${varName} has type ${typeName(\n        arg.type\n      )} but the following type was expected: ${typeName(typeHint)}`\n    );\n  }\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction usesFeatureId(encoded, context) {\n  context.featureId = true;\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsCount(minArgs, maxArgs) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `Expected ${range} arguments for ${operation}, got ${argCount}`\n      );\n    }\n  };\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction parseArgsOfType(argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            `, got ${gotType} but expected ${expectedType}`\n        );\n      }\n      expression.type &= argType;\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction narrowArgsType(encoded, context, parsedArgs) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n\n  // first pass to determine a narrowed down type\n  let sameType = AnyType;\n  for (let i = 0; i < parsedArgs.length; ++i) {\n    sameType &= parsedArgs[i].type;\n  }\n\n  if (sameType === NoneType) {\n    throw new Error(\n      `No common type could be found for arguments of ${operation} operation`\n    );\n  }\n\n  // re-parse args\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    args[i] = parse(encoded[i + 1], context, sameType);\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withOddArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withEvenArgs(encoded, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\n        argCount\n      )} instead`\n    );\n  }\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\n  const argsCount = encoded.length - 1;\n\n  const input = parse(encoded[1], context);\n  let inputType = input.type;\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context);\n    const output = parse(encoded[i + 3], context);\n    inputType &= match.type;\n    outputType &= output.type;\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  // check input and output types validity\n  const expectedInputType = StringType | NumberType | BooleanType;\n  if (!overlapsType(expectedInputType, inputType)) {\n    throw new Error(\n      `Expected an input of type ${typeName(\n        expectedInputType\n      )} for the interpolate operation` + `, got ${typeName(inputType)} instead`\n    );\n  }\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following match operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again inputs and outputs with common type\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    const match = parse(encoded[i + 2], context, inputType);\n    const output = parse(encoded[i + 3], context, outputType);\n    args[i] = match;\n    args[i + 1] = output;\n  }\n\n  return [\n    parse(encoded[1], context, inputType),\n    ...args,\n    parse(encoded[encoded.length - 1], context, outputType),\n  ];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\n  const interpolationType = encoded[1];\n  let interpolation;\n  switch (interpolationType[0]) {\n    case 'linear':\n      interpolation = 1;\n      break;\n    case 'exponential':\n      interpolation = interpolationType[1];\n      if (typeof interpolation !== 'number') {\n        throw new Error(\n          `Expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(interpolation)} instead`\n        );\n      }\n      break;\n    default:\n      interpolation = null;\n  }\n  if (!interpolation) {\n    throw new Error(\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`\n    );\n  }\n  interpolation = parse(interpolation, context);\n\n  // check input types\n  let input = parse(encoded[2], context);\n  if (!overlapsType(NumberType, input.type)) {\n    throw new Error(\n      `Expected an input of type number for the interpolate operation` +\n        `, got ${typeName(input.type)} instead`\n    );\n  }\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    let stop = parse(encoded[i + 3], context);\n    if (!overlapsType(NumberType, stop.type)) {\n      throw new Error(\n        `Expected all stop input values in the interpolate operation to be of type number` +\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`\n      );\n    }\n    let output = parse(encoded[i + 4], context);\n    if (!overlapsType(NumberType | ColorType, output.type)) {\n      throw new Error(\n        `Expected all stop output values in the interpolate operation to be a number or color` +\n          `, got ${typeName(output.type)} at position ${i + 3} instead`\n      );\n    }\n    // parse again with narrower types\n    stop = parse(encoded[i + 3], context, NumberType);\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\n    args[i] = stop;\n    args[i + 1] = output;\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\n  const fallback = parse(encoded[encoded.length - 1], context);\n  let outputType =\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\n\n  // first parse args to figure out possible types\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    const condition = parse(encoded[i + 1], context);\n    const output = parse(encoded[i + 2], context);\n    if (!overlapsType(BooleanType, condition.type)) {\n      throw new Error(\n        `Expected all conditions in the case operation to be of type boolean` +\n          `, got ${typeName(condition.type)} at position ${i} instead`\n      );\n    }\n    outputType &= output.type;\n    args[i] = condition;\n    args[i + 1] = output;\n  }\n\n  if (isType(outputType, NoneType)) {\n    throw new Error(\n      `Could not find a common output type for the following case operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  // parse again args with common output type\n  for (let i = 0; i < args.length - 1; i += 2) {\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\n  }\n  args[args.length - 1] = parse(\n    encoded[encoded.length - 1],\n    context,\n    outputType\n  );\n\n  return args;\n}\n\n/**\n * @type ArgValidator\n */\nfunction parseInArgs(encoded, context) {\n  /** @type {Array<number|string>} */\n  let haystack = /** @type {any} */ (encoded[2]);\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`\n    );\n  }\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`\n      );\n    }\n    haystack = haystack[1];\n  }\n\n  let needleType = StringType | NumberType;\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    const arg = parse(haystack[i], context);\n    needleType &= arg.type;\n    args[i] = arg;\n  }\n  if (isType(needleType, NoneType)) {\n    throw new Error(\n      `Could not find a common type for the following in operation: ` +\n        JSON.stringify(encoded)\n    );\n  }\n\n  const needle = parse(encoded[1], context, needleType);\n  return [needle, ...args];\n}\n\n/**\n * @type ArgValidator\n */\nfunction parsePaletteArgs(encoded, context) {\n  const index = parse(encoded[1], context, NumberType);\n  if (index.type !== NumberType) {\n    throw new Error(\n      `The first argument of palette must be an number, got ${typeName(\n        index.type\n      )} instead`\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('The second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    const color = parse(colors[i], context, ColorType);\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `The palette color at index ${i} must be a literal value`\n      );\n    }\n    if (!overlapsType(color.type, ColorType)) {\n      throw new Error(\n        `The palette color at index ${i} should be of type color, got ${typeName(\n          color.type\n        )} instead`\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\n * arguments\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\n * will be used as parsed arguments\n * @return {Parser} The parser.\n */\nfunction createParser(returnType, ...argValidators) {\n  return function (encoded, context, typeHint) {\n    const operator = encoded[0];\n    let parsedArgs = [];\n    for (let i = 0; i < argValidators.length; i++) {\n      parsedArgs =\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\n    }\n    let actualType =\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\n    if (typeHint !== undefined) {\n      if (!overlapsType(actualType, typeHint)) {\n        throw new Error(\n          `The following expression was expected to return ${typeName(\n            typeHint\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\n            encoded\n          )}`\n        );\n      }\n      actualType &= typeHint;\n    }\n    if (actualType === NoneType) {\n      throw new Error(\n        `No matching type was found for the following expression: ${JSON.stringify(\n          encoded\n        )}`\n      );\n    }\n    return new CallExpression(actualType, operator, ...parsedArgs);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @param {number} [typeHint] Optional type hint\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context, typeHint) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context, typeHint);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,QAAQ,GAAG,CAAC,CAAC;AACL,MAAC,QAAQ,GAAG,EAAE;AACd,MAAC,WAAW,GAAG,CAAC,IAAI,QAAQ,GAAG;AAC/B,MAAC,UAAU,GAAG,CAAC,IAAI,QAAQ,GAAG;AAC9B,MAAC,UAAU,GAAG,CAAC,IAAI,QAAQ,GAAG;AAC9B,MAAC,SAAS,GAAG,CAAC,IAAI,QAAQ,GAAG;AAC7B,MAAC,eAAe,GAAG,CAAC,IAAI,QAAQ,GAAG;AACnC,MAAC,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAG,EAAE;AACjD;AACA,MAAM,SAAS,GAAG;AAClB,EAAE,CAAC,WAAW,GAAG,SAAS;AAC1B,EAAE,CAAC,UAAU,GAAG,QAAQ;AACxB,EAAE,CAAC,UAAU,GAAG,QAAQ;AACxB,EAAE,CAAC,SAAS,GAAG,OAAO;AACtB,EAAE,CAAC,eAAe,GAAG,UAAU;AAC/B,CAAC,CAAC;AACF;AACA,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,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","x_google_ignoreList":[0]}