{"version":3,"file":"color.js","sources":["../../../node_modules/ol/color.js"],"sourcesContent":["/**\n * @module ol/color\n */\nimport lchuv from 'color-space/lchuv.js';\nimport parseRgba from 'color-rgba';\nimport rgb from 'color-space/rgb.js';\nimport xyz from 'color-space/xyz.js';\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * @type {number}\n */\nconst MAX_CACHE_SIZE = 1024;\n\n/**\n * We maintain a small cache of parsed strings.  Whenever the cache grows too large,\n * we delete an arbitrary set of the entries.\n *\n * @type {Object<string, Color>}\n */\nconst cache = {};\n\n/**\n * @type {number}\n */\nlet cacheSize = 0;\n\n/**\n * @param {Color} color A color that may or may not have an alpha channel.\n * @return {Color} The input color with an alpha channel.  If the input color has\n * an alpha channel, the input color will be returned unchanged.  Otherwise, a new\n * array will be returned with the input color and an alpha channel of 1.\n */\nexport function withAlpha(color) {\n  if (color.length === 4) {\n    return color;\n  }\n  const output = color.slice();\n  output[3] = 1;\n  return output;\n}\n\n/**\n * @param {Color} color RGBA color.\n * @return {Color} LCHuv color with alpha.\n */\nexport function rgbaToLcha(color) {\n  const output = xyz.lchuv(rgb.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {Color} color LCHuv color with alpha.\n * @return {Color} RGBA color.\n */\nexport function lchaToRgba(color) {\n  const output = xyz.rgb(lchuv.xyz(color));\n  output[3] = color[3];\n  return output;\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport function fromString(s) {\n  if (cache.hasOwnProperty(s)) {\n    return cache[s];\n  }\n  if (cacheSize >= MAX_CACHE_SIZE) {\n    let i = 0;\n    for (const key in cache) {\n      if ((i++ & 3) === 0) {\n        delete cache[key];\n        --cacheSize;\n      }\n    }\n  }\n\n  const color = parseRgba(s);\n  if (color.length !== 4) {\n    throw new Error('Failed to parse \"' + s + '\" as color');\n  }\n  for (const c of color) {\n    if (isNaN(c)) {\n      throw new Error('Failed to parse \"' + s + '\" as color');\n    }\n  }\n  normalize(color);\n  cache[s] = color;\n  ++cacheSize;\n  return color;\n}\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * Exported for the tests.\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  try {\n    fromString(s);\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n"],"names":["parseRgba"],"mappings":"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","x_google_ignoreList":[0]}